ReentrantLock
======

一个可重入的互斥锁。

意思指同一个线程内，可以重复获得多次锁，在任意方法调用栈位置，释放时，也要释放获得锁的次数才能完全释放。

内部维护了一个计数器，每次获取锁时加1，释放锁时减1，当为0时表示真正释放了锁。最大为2147483648。

可以使用 `isHeldByCurrentThread` 方法来判断当前线程是否获得锁，使用 `getHoldCount` 可知道当前线程获得了几次锁。


ReentrantLock() & ReentrantLock(boolean fair)
-------------------------

`ReentrantLock()` 等同于使用 `ReentrantLock(false)`。

`ReentrantLock(boolean fair)` 创建一个具有给定公平策略的 ReentrantLock。

当 `fair` 设置为 `true` 时，在多个线程的争用下，这些锁倾向于将访问权授予等待时间最长的线程。
否则此锁将无法保证任何特定访问顺序。与采用默认设置（使用不公平锁）相比，使用公平锁的程序在许多线程访问时表现为很低的
总体吞吐量（即速度很慢，常常极其慢），但是在获得锁和保证锁分配的均衡性时差异较小。不过要注意的是，公平锁不能保证线程
调度的公平性。因此，使用公平锁的众多线程中的一员可能获得多倍的成功机会，这种情况发生在其他活动线程没有被处理并且目前
并未持有锁时。

还要注意的是，未定时的 `tryLock` 方法并没有使用公平设置。因为即使其他线程正在等待，只要该锁是可用的，此方法就可以获得成功。

从 Lock 接口 继承的方法的不同点
------------

- lock() ：获得锁时，将计数器加1。
- lockInterruptibly() ：获得锁时，将计数器加1。
- tryLock()：尝试获取锁，将计数器加1。不支持排序，可以用于打破公平场景。
- tryLock(long timeout, TimeUnit unit)：在指定时间内获取锁。将计数器加1。支持排序。
- unlock()：释放锁。计数器减1。计数为 0，则真正释放锁，其它线程可以抢锁。

getHoldCount()
-------
查询当前线程拥有此锁的次数，因为当前线程可以多次重入。
对于与解除锁操作不匹配的每个锁操作，线程都会保持一个锁。 

isHeldByCurrentThread()
-------------------------
查询当前线程是否保持此锁。

isLocked()
----
查询此锁是否由某个线程获取。

isFair()
----
查询此锁是否为公平的，如果是返回 `true` 。

getOwner()
----------
返回目前拥有此锁的线程，如果此锁不被任何线程拥有，则返回 null。

hasQueuedThreads()
------------
查询是否有些线程正在等待获取此锁。注意，因为随时可能发生取消，所以返回 true 并不保证有其他线程将获取此锁。

hasQueuedThread(Thread thread)
---------
查询给定线程是否正在等待获取此锁。注意，因为随时可能发生取消，所以返回 true 并不保证此线程将获取此锁。

getQueueLength()
----------
返回正等待获取此锁的线程估计数。该值仅是估计的数字，因为在此方法遍历内部数据结构的同时，线程的数目可能动态地变化。

getQueuedThreads()
----------
返回一个 collection，它包含可能正等待获取此锁的线程。
因为在构造此结果的同时实际的线程 set 可能动态地变化，所以返回的 collection 仅是尽力的估计值。

hasWaiters(Condition condition)
-----------------
查询是否有些线程正在等待与此锁有关的给定条件。注意，因为随时可能发生超时和中断，所以返回 true 并不保证将来某个 signal 将唤醒线程。

getWaitQueueLength(Condition condition)
----------
返回等待与此锁相关的给定条件的线程估计数。注意，因为随时可能发生超时和中断，所以只能将估计值作为实际等待线程数的上边界。

getWaitingThreads(Condition condition)
-----------
返回一个 collection，它包含可能正在等待与此锁相关给定条件的那些线程。
因为在构造此结果的同时实际的线程 set 可能动态地变化，所以返回 collection 的元素只是尽力的估计值。
所返回 collection 中的元素没有特定的顺序。