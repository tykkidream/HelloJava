Concurrent Lesson 11 学习
==========================

需求
---------------

一般向的线程池内提交任务执行，可能有3种情况：

- 任务正常的快速执行结束。
- 任务执行的时间有点长，超出了一般所需的最大时间。
- 任务执行的时间特别长，远远超出了一般所需要最大时间，甚至好像永远不会停。

需要实现一个工具类，实现如下功能：

- 需要实现一个检测超时并中断任务的功能。
- 需要实现一个检测超时，再等待一些时间，这段时间内任务可能执行完，但等待结束后，杀死任务的功能。

思路
-----

当一个线程在执行时，是无法及时知道自己已超时的，需要另一个线程来进行检测时间才能知道是否超时。

所以简单来说，思路为：

一个工作线程用于真正执行任务，另一个控制线程检测工作线程是否超时。当检测到超时时，直接中断线程。但工作线程不可能立刻停止，所以需要再等待一个最后期限，工作线程应该在此时间内结束。如果最后期限内工作线程还没结束，直接杀死工作线程。控制线程应伴生工作线程，同生共死。

最后期限的时间可以稍长一些。因为超时时间可能设置的比较短，还可保留任务在最后期限内正常完成的机会。如果最后期限的时间都不够用，说明任务有可能处理的内容远远超出了工作量，甚至发生了类似死锁的不可预期的大问题，这种情况不应该一直等下去，应分析到底出了什么问题。

实现
------

创建两个线程池：一个为真正执行任务的，名为工作线程池，另一个为检测任务是否超时，并控制中断或杀死任务的，名为控制线程池。

工作线程池和控制线程池的大小等，要一模一样。

执行时，首先由控制线程池首先接收任务，然后将任务 `submit` 给工作线程池处理。`submit` 应该是阻塞式的，以保证任务在工作线程池内执行开始时，控制线程能大体上同时开始监测超时，也就是满足控制线程和工作线程基本上同时开始执行的要求，所以创建工作线程池时，应使用 `SynchronousQueue` 队列。

接下来工作线程执行任务，控制线程则通过工作线程的 `Future` 对象等待工作线程执行完成，并指定上等待的时间为超时时间。

任务正常完成后，控制线程获取到任务执行的结果，将结果返回给外部请求。

如果等待超时，则执行 `Future` 对象的 `cancel` 方法取消任务执行。

判断最后期限时间大小，如果大于0，视为需要继续等待，也意味着如果等待还是超时，就可以杀死线程。如果小于等待0，视为不处理任务超时，任由任务自生自灭。

由于 `Future` 对象的 `cancel` 被执行后， `get` 方法将无法再使用。但为了能使用超时机会，通过 `CountDownLatch` 来实现，需要在控制线程将任务 `submit` 给工作线程池之前，做一些事：

- 控制线程开始时，创建一个 `CountDownLatch` 对象，大小为1。
- 将用户的 `Runnable` 或 `Callable` 封装起来，内部逻辑为调用其执行方法，最后执行 `CountDownLatch` 的 `countDown` 方法。

控制线程再通过 `CountDownLatch` 对象的 `await` 方法继续等待工作线程执行结束，并指定上等待的时间为最后期限时间。

如果等待中，工作线程结束，那么控制线程也结束。

如果等待还是超时，反射获取 `Future` 对象上的 `runner` 字段，其为工作线程对象，执行其 `stop`、`suspend`、`resume` 来强制杀死线程。

控制线程到此结束。

代码：[TimeoutThreadPool](src/main/java/hellojava/concurrent/lesson11/TimeoutThreadPool.java)

示例
--------

代码：

- [Demo](src/main/java/hellojava/concurrent/lesson11/Demo.java) 演示 `TimeoutThreadPool` 处理需求的效果。
- [DemoThreadFactory](src/main/java/hellojava/concurrent/lesson11/DemoThreadFactory.java) 创建工作线程的工厂，为了说明 `Demo` 中杀死线程的效果。

注意示例中的第一个任务超时，被杀死后，注意一个现象：

1. 首先有两个任务开始执行，各有不同的执行时间和超时时间。注意此时工作线程的名字。
1. 第1个任务 `sleep` 时间为50秒，远远超过超时时间。
1. 第1、2个任务还未结束前，新的第3、4个任务被提交，新任务在等待第1、2个任务执行完成。
1. 当第2个任务执行完成后，第3个新任务开始执行，第4个还在继续等待。
1. 第1个任务经过了超时时间、最后期限时间，执行此任务的线程被成功杀死，打印出此线程名。
1. 第4个任务开始执行，通过日志中的线程名可以知道，是由于执行第1个任务和线程执行，而此时是还在第1个任务的50秒内的。
1. 第5个任务为正常使用示例。

此现象说明，杀死线程池中的线程，确实达到了将任务强制结束的效果，但线程实际未被真正杀死。其实 `Future` 的 `cancel` 方法也是这个现象。
